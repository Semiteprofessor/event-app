generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String  @id @default(cuid())
  firstName        String
  lastName         String
  email            String  @unique
  password         String
  gender           Gender
  coverId          String?
  coverUrl         String?
  coverBlurDataURL String?

  wishlist Product[] @relation("Wishlist")
  orders   Order[]   @relation("UserOrders")
  shop     Shop?     @relation(fields: [shopId], references: [id])
  shopId   String?

  recentProducts    Product[] @relation("RecentProducts")
  likedProducts     Product[] @relation("LikedProducts")
  purchasedProducts Product[] @relation("PurchasedProducts")

  phone   String
  status  String?
  address String?
  city    String?
  zip     String?
  country String?
  state   String?
  about   String?

  isVerified    Boolean   @default(false)
  otp           String
  lastOtpSentAt DateTime?
  commission    Float?

  role Role

  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  RefreshToken  RefreshToken[]
  ProductReview ProductReview[]
  Review        Review[]
  Order         Order[]
  Product       Product[]

}

enum Gender {
  male
  female
  other
}

enum Role {
  SUPER_ADMIN
  ADMIN
  USER
  VENDOR
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Product {
  id              String      @id @default(cuid())
  name            String?
  code            String?
  status          String?
  isFeatured      Boolean?
  brandId         String?
  brand           Brand?      @relation(fields: [brandId], references: [id])
  likes           Int?
  description     String?
  metaTitle       String?
  metaDescription String?
  slug            String      @unique
  categoryId      String
  category        Category    @relation(fields: [categoryId], references: [id])
  subCategoryId   String
  subCategory     SubCategory @relation(fields: [subCategoryId], references: [id])
  gender          String?
  tags            String[]
  sku             String
  price           Float
  priceSale       Float
  oldPriceSale    Float?
  available       Int
  sold            Int         @default(0)

  shopId String
  shop   Shop   @relation(fields: [shopId], references: [id])

  reviews ProductReview[]

  images ProductImage[]

  colors String[]
  sizes  String[]

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  User              User?               @relation(fields: [userId], references: [id])
  userId            String?
  ProductOnCompaign ProductOnCompaign[]
}

model ProductImage {
  id          String  @id @default(cuid())
  url         String
  imageId     String
  blurDataURL String
  productId   String
  product     Product @relation(fields: [productId], references: [id])
}

model ProductReview {
  id        String  @id @default(cuid())
  userId    String
  user      User    @relation(fields: [userId], references: [id])
  productId String
  product   Product @relation(fields: [productId], references: [id])

  review      String
  rating      Int
  isPurchased Boolean

  images ReviewImage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ReviewImage {
  id          String        @id @default(cuid())
  url         String
  blurDataURL String
  reviewId    String
  review      ProductReview @relation(fields: [reviewId], references: [id])
}

model Review {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  rating      Int
  review      String
  designation String
  createdAt   DateTime @default(now())
}

model Category {
  id              String @id @default(cuid())
  name            String @db.VarChar(100)
  metaTitle       String @db.VarChar(100)
  description     String @db.VarChar(500)
  metaDescription String @db.VarChar(200)
  slug            String @unique
  status          String

  coverId          String
  coverUrl         String
  coverBlurDataURL String

  subCategories SubCategory[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  Product   Product[]
}

model SubCategory {
  id String @id @default(cuid())

  coverId          String
  coverUrl         String
  coverBlurDataURL String

  name            String @db.VarChar(100)
  metaTitle       String @db.VarChar(100)
  description     String @db.VarChar(500)
  metaDescription String @db.VarChar(200)
  slug            String
  status          String

  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  Product   Product[]
}

model Brand {
  id String @id @default(cuid())

  // Flattened logo fields
  logoId          String
  logoUrl         String
  logoBlurDataURL String

  name            String
  metaTitle       String
  description     String
  metaDescription String
  slug            String @unique
  status          String

  // Optional relation: one brand â†’ many products
  products Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Shop {
  id String @id @default(cuid())

  vendorId String
  vendor   User   @relation(fields: [vendorId], references: [id])

  logoId          String
  logoUrl         String
  logoBlurDataURL String

  coverId          String
  coverUrl         String
  coverBlurDataURL String

  title           String
  metaTitle       String
  description     String
  metaDescription String
  slug            String  @unique
  phone           String  @unique
  website         String?

  approved   Boolean   @default(false)
  approvedAt DateTime?

  status  ShopStatus
  message String?

  country       String
  city          String
  state         String
  streetAddress String

  paymentHolderName  String
  paymentHolderEmail String
  paymentBankName    String
  paymentAccountNo   Int

  followers User[]    @relation("ShopFollowers")
  products  Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ShopStatus {
  approved
  pending
  in_review
  action_required
  blocked
  rejected
}

enum PaymentMethod {
  Paystack
  Flutterwave
  Stripe
  PayPal
  COD
}

enum OrderStatus {
  pending
  on_the_way
  delivered
  canceled
  returned
}

model Order {
  id             String        @id @default(cuid())
  paymentMethod  PaymentMethod
  orderNo        String
  paymentId      String?
  subTotal       Float
  total          Float
  totalItems     Int
  shipping       Float
  discount       Float?
  currency       String
  conversionRate Float
  status         OrderStatus?
  items          Json?
  note           String?

  userId String
  user   User   @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum DiscountType {
  fixed
  percent
}

enum CompaignStatus {
  enable
  disable
}

model Compaign {
  id            String @id @default(cuid())
  coverId       String
  coverUrl      String
  coverBlurData String

  name            String @db.VarChar(100)
  metaTitle       String @db.VarChar(100)
  description     String @db.VarChar(500)
  metaDescription String @db.VarChar(200)
  slug            String @unique

  startDate DateTime
  endDate   DateTime

  discountType DiscountType
  discount     Float
  status       CompaignStatus @default(enable)

  // relation: One campaign -> Many products
  products ProductOnCompaign[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProductOnCompaign {
  compaignId String
  productId  String

  compaign Compaign @relation(fields: [compaignId], references: [id])
  product  Product  @relation(fields: [productId], references: [id])

  @@id([compaignId, productId])
}

